En el programa de ejemplo StopWatch que se nos provee, podemos observar la forma en la que se maneja el LCD de nuestra placa, 


Inicialmente contamos con slcdInitialize, para inicializar el LCD, al cual tenemos que habilitarle la señal de reloj para los puertos B, C, D, E, y el propio módulo sLCD.

Tras ello configuramos los pines, y configuramos el registro del sLCD (LCD->GCR)

Posteriormente continuamos configurando más parámetros, que no voy a tratar uno por uno, pero que con ellos sacamos en conclusión que el LCD, es un periférico más, que por
supuesto es más complejo de usar que un único LED, pero que al final del día, tiene un funcionamiento similar, es decir, tenemos que activarle señales de reloj, configurar
sus pines y su registro, etc.

La función más interesante en  slcd.c es slcdSet, puesto que es la que hace el trabajo por nosotros de mostrar en qué sitio, qué número, y lo hace de forma muy sencilla.

Para los que estamos acostumbrados a programar sistemas como Arduino o similares, es un comportamiento muy parecido: En Arduino escribíamos directamente el número en binario,
como por ejemplo 0b01111111 para el número 8. Aquí tenemos unos #define, cada uno activando un bit.

Así, podemos hacer las cosas un poco más ``elegantes'' usando bitwise-or. Por ejemplo, el 8 sería:

% verbatim
LCD->WF8B[LCD_Front_Pin[((2*digit)-2)]] = (LCD_S_G | LCD_S_E | LCD_S_D  | LCD_S_F);
LCD->WF8B[LCD_Front_Pin[((2*digit)-1)]] = (LCD_S_A | LCD_S_B | LCD_S_C);
% end

donde hacemos un or de cada uno de los bits que encienden un segmento.

Además, el módulo sLCD con el que contamos tiene una particularidad, y es que cada dígito está dividido en dos subsegmentos, FP0 y FP1, tal que

% verbatim
FP0 - Front Plane 0
 f |_g
 e |_
     d

FP1 - Front Plane 1
   a_
     | b
   c |. dot
% end

por lo que tenemos que poner los flags en el sitio correcto, ((2*digit)-2) para FP0, y ((2*digit)-1) para FP1.


Finalmente, contamos con tres funciones autodescriptivas, que son slcdDisplay, el cual nos muestra el número de 16 bits `value'
en el formato deseado (esto segundo no está implementado); slcdClear, que hace lo que su nombre indica, borrar el display; y slcdDemo, que es el que se ejecuta
al inicio del programa StopWatch, y que muestra cada uno de los números en hexadecimal en la pantalla uno despues de otro, de forma circular, limpiando la pantalla tras
escribir cada uno de ellos.

Se ve muy claramente en el código:

% verbatim
for(i=0; i < 0x10; i++){
	slcdClear();
	slcdSet(i, i%4 + 1);
	msDelay(300);
	slcdClear();
}
% end


También he tenido que corregir el código de slcdSet, ya que los números 1, 2 y 3 no estaban programados,
y 0xB estaba con los regiones del dígito intercambiadas