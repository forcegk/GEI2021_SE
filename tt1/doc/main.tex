\documentclass[a4paper,openright,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx} 
\usepackage{subfigure}
\usepackage[mathscr]{eucal}
\usepackage{titling}
\usepackage{float}
\usepackage{amsmath}
\usepackage{afterpage}
\usepackage{vmargin}
\usepackage[spanish,es-noshorthands]{babel}
\usepackage{csquotes}
\usepackage{eurosym} 
\usepackage{multirow}
\usepackage{xcolor}
\usepackage[export]{adjustbox}
\usepackage{url}
\usepackage[T1]{fontenc}
\usepackage{inconsolata}
\usepackage{listings}
\usepackage{minted}
\usepackage{amsfonts}
\usepackage[backend=biber, style=authoryear-icomp]{biblatex}
\usepackage[none]{hyphenat}
\sloppy
\usepackage[document]{ragged2e}
\usepackage[shortlabels]{enumitem}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\usepackage{datetime}
\usepackage{mfirstuc}
\setlist[enumerate]{itemsep=0mm}
\setlist[itemize]{itemsep=0mm}
\addbibresource{bibliography.bib}

% Packages for FSM
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

% Things for Morse
\newcommand{\punto}{\kern+0.3pt\raisebox{0.35ex}{\huge\textbf.}}
\newcommand{\raya}{\kern+0.2pt\raisebox{-0.35ex}{\huge\textbf-}}

% Para generar imágenes mock
\usepackage{duckuments}

\setpapersize{A4}       %  DIN A4
\setmargins{3cm}        % margen izquierdo
{2cm}                   % margen superior
{15cm}                  % anchura del texto
{22.5cm}                % altura del texto
{10pt}                  % altura de los encabezados
{1cm}                   % espacio entre el texto y los encabezados
{0pt}                   % altura del pie de página
{2cm}                   % espacio entre el texto y el pie de página

\begin{document}

\author {Alonso Rodríguez}
\title {Trabajo Tutelado I}

% Título
\maketitle

% Justificamos el texto
\justifying{}

\section{Introducción}
En esta primera iteración de este trabajo tutelado, realizaremos una aproximación inicial al problema que como ingenieros
tratamos de resolver.

Nuestra misión es definir la máquina de estado finito (FSM) para un subconjunto del código morse, por simplificar la implementación.
En concreto debemos definirla, y posteriormente implementarla para los caracteres:
\begin{itemize}
    \item `A' (\punto\raya)
    \item `J' (\punto\raya\raya\raya)
    \item `S' (\punto\punto\punto)
    \item `O' (\raya\raya\raya)
    \item `2' (\punto\punto\raya\raya\raya)
\end{itemize} 

Además, se detalla cómo utilizar el LCD del dispositivo que vamos a emplear en la segunda fase de este mismo trabajo para implementar este dispositivo morse:
la placa FRDM-KL46Z.

\section{Detalles acerca del Código Morse}
\begin{itemize}
    \item La unidad de tiempo no está definida, así que le llamaremos ``tick''
    \item Los puntos (\punto) duran 1 tick
    \item Las rayas (\raya) duran 3 ticks
    \item El espacio intra-carácter es de 1 tick
    \item El espacio inter-carácter es de 3 ticks
    \item El espacio inter-palabra es de 7 ticks
\end{itemize}


\section{Máquina de Estado Finito}
Para la implementación de esta FSM consideramos estados con tres posibles entradas:
\begin{itemize}
    \item Vacío ($\emptyset$): El usuario no pulsa el botón
    \item Punto (\punto): El usuario pulsa el botón durante 1 tick
    \item Raya (\raya): El usuario pulsa el botón durante 3 ticks
\end{itemize}

Cuando el usuario presiona el botón (SW1) para introducir un punto, el LED verde se enciende durante 1 tick, y cuando se pulsa el de la raya (SW2), durante 3 ticks.
Tras esto, se espera un tick, a no ser que estemos en un nodo terminal (en el que se escribe un carácter), en cuyo caso se espera tres ticks, y se enciende el led rojo.

Esto podría añadirlo a la FSM, pero considero que es algo sencillo de observar sin necesidad de saturar más la misma.

De todos modos, podemos extender la máquina de estados con este comportamiento, donde \punto \space significa pulsar SW1, y \raya \space SW2:

\begin{center}
\begin{tikzpicture}[->,>=stealth, shorten >=1pt, auto, node distance=3.2cm, semithick]
    \tikzstyle{every state}=[draw=black,text=black]

    % Nodo inicial
    \node[initial,state]        (vacio)                                     {$\frac{\emptyset}{\overset{\emptyset}{0}}$};

    % Puntos y rayas
    \node[state]                (punto)    [below right of=vacio]           {$\frac{\punto}{\overset{\punto}{\text{\textcolor{green}{\punto} + 1tick}}}$};
    \node[state]                (raya)     [above right of=vacio]           {$\frac{\raya}{\overset{\raya}{\text{\textcolor{green}{\punto} + 3tick}}}$};
    
    % Encendemos LED rojo y LCD
    \node[state, right=7cm, accepting]     (flush)    [right of=vacio]      {$\frac{\emptyset}{\overset{\text{\scriptsize{Muestra LCD}}}{\text{Enciende LED \textcolor{red}{\punto}}}}$};

    % Esperamos 3 segundos
    \node[state, right=2.5cm]              (hold)     [right of=vacio]      {$\frac{\emptyset}{\overset{\emptyset}{\text{máx 3tick}}}$};


    \path
        (vacio) edge                                node {\punto}           (punto)
                edge                                node {\raya}            (raya)
        (punto) edge [loop below]                   node {\punto}           (punto)
                edge [bend left=10, looseness=1]    node {\raya}            (raya)
                edge [bend right=12, looseness=1]   node {$\emptyset$}      (hold)
        (raya)  edge [bend left=10, looseness=1]    node {\punto}           (punto)
                edge [loop above]                   node {\raya}            (raya)
                edge [bend left=12, looseness=1]    node {$\emptyset$}      (hold)
        (hold)  edge [bend right=12, looseness=1]   node {\punto}           (punto)
                edge [bend left=12, looseness=1]    node {\raya}            (raya)
                edge                                node {$\emptyset$}      (flush)

    ;
\end{tikzpicture}
\end{center}

Para oxigenar el diagrama, en cada nodo que no se especifica el comportamiento de $\emptyset$, \punto, o \raya, significa que dada esa entrada, se vuelve al estado inicial.

\clearpage

\subsection{Diagrama general de la FSM}
\bigskip\bigskip\bigskip % Dejamos espacio por el pgfinterruptboundingbox que hace que las flechas se nos metan en medio del título de la subsección
\begin{center}
\begin{tikzpicture}[->,>=stealth, shorten >=1pt, auto, node distance=3.2cm, semithick]
    \tikzstyle{every state}=[draw=black,text=black]

    % Nodo inicial
    \node[initial,state] (vacio)                              {$\frac{\emptyset}{\overset{\emptyset}{0}}$};

    % Camino a A, J
    \node[state]         (1p)     [below right of=vacio]      {$\frac{\punto}{\overset{\emptyset}{1}}$};
    \node[state]         (1p1r)   [below left  of=1p]         {$\frac{\punto\raya}{\overset{\emptyset}{1}}$};
    \node[state]         (1p2r)   [below left  of=1p1r]       {$\frac{\punto\raya\raya}{\overset{\emptyset}{1}}$};
    \node[state]         (1p3r)   [below left  of=1p2r]       {$\frac{\punto\raya\raya\raya}{\overset{\emptyset}{1}}$};

    % Camino a O
    \node[state]         (1r)     [below left  of=vacio]      {$\frac{\raya}{\overset{\emptyset}{1}}$};
    \node[state]         (2r)     [below left  of=1r]         {$\frac{\raya\raya}{\overset{\emptyset}{1}}$};
    \node[state]         (3r)     [below left  of=2r]         {$\frac{\raya\raya\raya}{\overset{\emptyset}{1}}$};

    % Camino a S, 2 desde 1p
    \node[state]         (2p)     [below right of=1p]         {$\frac{\punto\punto}{\overset{\emptyset}{1}}$};
    \node[state]         (3p)     [below right of=2p]         {$\frac{\punto\punto\punto}{\overset{\emptyset}{1}}$};
    \node[state]         (2p1r)   [below left  of=2p]         {$\frac{\punto\punto\raya}{\overset{\emptyset}{1}}$};
    \node[state]         (2p2r)   [below left  of=2p1r]       {$\frac{\punto\punto\raya\raya}{\overset{\emptyset}{1}}$};
    \node[state]         (2p3r)   [below left  of=2p2r]       {$\frac{\punto\punto\raya\raya\raya}{\overset{\emptyset}{1}}$};

    % Puntos finales
    \node[state]         (S)      [below of=3p]               {$\frac{\text{ `S' }}{\overset{\text{S}}{2}}$};
    \node[state]         (A)      [below left of=S]           {$\frac{\text{ `A' }}{\overset{\text{A}}{2}}$};
    \node[state]         (J)      [below of=1p3r]             {$\frac{\text{ `J' }}{\overset{\text{J}}{2}}$};
    \node[state]         (O)      [below of=3r]               {$\frac{\text{ `O' }}{\overset{\text{O}}{2}}$};
    \node[state]         (2)      [below of=2p3r]             {$\frac{\text{ `2' }}{\overset{\text{2}}{2}}$};

    \begin{pgfinterruptboundingbox}
    \path
        (vacio) edge                node {\punto}         (1p)
                edge                node {\raya}          (1r)
                edge [loop above]   node {$\emptyset$}    (vacio)
        (1p)    edge                node {\raya}          (1p1r)
                edge                node {\punto}         (2p)
        (1p1r)  edge                node {\raya}          (1p2r)
                edge [bend right=5] node {$\emptyset$}    (A)
        (1p2r)  edge                node {\raya}          (1p3r)
        (1p3r)  edge                node {$\emptyset$}    (J)
        (2p)    edge                node {\punto}         (3p)
                edge                node {\raya}          (2p1r)
        (3p)    edge                node {$\emptyset$}    (S)
        (2p1r)  edge                node {\raya}          (2p2r)
        (2p2r)  edge                node {\raya}          (2p3r)
        (2p3r)  edge                node {$\emptyset$}    (2)

        (1r)    edge                node {\raya}          (2r)
        (2r)    edge                node {\raya}          (3r)
        (3r)    edge                node {$\emptyset$}    (O)

        % Los de vuelta
        (A)    edge [bend left=240, looseness=1.5,in=250]          node {}                (vacio)
        (J)    edge [bend right=240,looseness=1.5,in=100]         node {}                (vacio)
        (S)    edge [bend left=240, looseness=1,  in=250]          node {}                (vacio)
        (O)    edge [bend right=240,looseness=1,  in=100]         node {}                (vacio)
        (2)    edge [bend right=240,looseness=1.75,  in=100]       node {}                (vacio)
    ;
    \end{pgfinterruptboundingbox}
\end{tikzpicture}
\end{center}

\bigskip
Aquí nos damos cuenta de que siempre vamos a saber qué letra hemos pulsado inequívocamente excepto en la A, cuyo código consiste en comenzar a teclear la J, pero interrumpir
el proceso en el segundo nodo. (\punto\raya)

En este caso, lo que haremos será dar un cierto margen, y, a la espera de posibles complicaciones durante la implementación, de momento voy a atreverme a avanzar que en
estos casos, para compensar la imprecisión humana, se contarán hasta los tres ticks para determinar que se ha terminado de introducir una letra.
Es decir, que si desde que he pulsado \punto\raya \space han transcurrido 1.5 tick, sigo estando a tiempo de pulsar otra \raya. Pero en el momento que pasen 3 tick,
ya se dará por hecho que se ha terminado. En este sentido, el diagrama no refleja TAN fielmente la realidad, pero pienso que esta es la forma más adecuada para representar
esta máquina de estado finito, y a la vez contemplar que los seres humanos no somos máquinas perfectas.

Queda por detallar cómo vamos a determinar la duración de los ticks. Se plantean dos opciones que se detallarán en el siguiente entregable.
Destacar que a mi me gustaría optar por la segunda:

\begin{itemize}
    \item 1 tick = 1 segundo, 0.5 segundos, o una medida arbitraria fija.
    \item 1 tick = media de las duraciones en segundos por espacio anteriores.
\end{itemize}

Es decir, que si de media yo hago un espacio de 0.25s entre símbolos, si hago una pausa > 0.75s, significará que el señalizado del carácter ha concluido, y por tanto debe
encenderse el LED rojo y mostrarse el carácter correspondiente en el LCD.

\section{Comportamiento del LCD}
En el programa de ejemplo `StopWatch' que se nos provee, podemos observar la forma en la que se maneja el LCD de nuestra placa:

\subsection{Inicialización}
Para esto contamos con `slcdInitialize'.

Para inicializarlo, tenemos que habilitarle la señal de reloj para los puertos B, C, D, E, y al propio módulo sLCD.

Tras ello configuramos los pines, y configuramos el registro del sLCD \texttt{(LCD->GCR)}.

Posteriormente continuamos configurando más parámetros, que no voy a tratar uno por uno, pero que con ellos sacamos en conclusión que el LCD es un periférico más, que por
supuesto es más complejo de usar que un único LED, pero que al final del día, tiene un funcionamiento similar, es decir, tenemos que activarle señales de reloj, configurar
sus pines y su(s) registro(s), etc.

\subsection{Impresión de Caracteres}
La función más interesante (y que probablemente más vamos a usar) en slcd.c es `slcdSet', puesto que es la que hace el trabajo por nosotros de qué mostrar en que sitio,
que número, y lo hace de forma muy sencilla.

Para los que estamos acostumbrados a programar sistemas como Arduino o similares, es un comportamiento muy parecido: En Arduino escribíamos directamente el número en binario,
como por ejemplo 0b01111111 para el número 8. Aquí tenemos unos \#define, cada uno activando un bit.

Así, podemos hacer las cosas un poco más ``elegantes'' usando bitwise-or. Por ejemplo, el 8 sería:

\begin{minted}{c}
LCD->WF8B[LCD_Front_Pin[((2*digit)-2)]] = (LCD_S_G | LCD_S_E |
                                           LCD_S_D | LCD_S_F);
LCD->WF8B[LCD_Front_Pin[((2*digit)-1)]] = (LCD_S_A | LCD_S_B | LCD_S_C);
\end{minted}
donde hacemos un or de cada uno de los bits que encienden un segmento.

\subsubsection{Detalles del panel LCD}
Además, el módulo sLCD con el que contamos tiene una particularidad, y es que cada dígito está dividido en dos subsegmentos, FP0 y FP1, tal que

\begin{samepage}
\begin{verbatim}
        FP0 - Front Plane 0             FP1 - Front Plane 1
        f |_g                           a_
        e |_                              | b
            d                           c |. dot
\end{verbatim}
\end{samepage}
por lo que tenemos que poner los flags en el sitio correcto, \texttt{((2*digit)-2)} para FP0, y \texttt{((2*digit)-1)} para FP1.

\subsection{Otras funciones}
Finalmente, contamos con tres funciones autodescriptivas, que son:
\begin{enumerate}[a]
    \item slcdDisplay   \label{otras_func_slcdDisplay}
    \item slcdClear     \label{otras_func_slcdClear}
    \item slcdDemo      \label{otras_func_slcdDemo}
\end{enumerate}


`slcdDisplay' (\ref{otras_func_slcdDisplay}), nos muestra el número de 16 bits `value' en el formato deseado (esto segundo aún no está implementado).

`slcdClear' (\ref{otras_func_slcdClear}), que hace lo que su nombre indica, borrar el display.

`slcdDemo' (\ref{otras_func_slcdDemo}), que es el que se ejecuta en el programa StopWatch, y que muestra cada uno de los números en hexadecimal en la pantalla uno
despues de otro, de forma circular, limpiando la pantalla tras escribir cada uno de ellos.

Se ve muy claramente en el código:
\begin{minted}{c}
    for(i=0; i < 0x10; i++){
        slcdClear();
        slcdSet(i, i%4 + 1);
        msDelay(300);
        slcdClear();
    }   
\end{minted}

También he tenido que corregir el código de `slcdSet', y `slcdErr', ya que los números 1, 2 y 3 no estaban programados,
y 0xB estaba con las regiones del dígito intercambiadas, y falta por implementar una parte de `slcdDisplay'; puntos que trataremos en la
segunda entrega de este trabajo tutelado.


\printbibliography[]{}
\end{document}