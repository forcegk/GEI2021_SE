\documentclass[a4paper,openright,12pt]{article}

\include{preamble/packages}
\include{preamble/bibliography}

\setpapersize{A4}       %  DIN A4
\setmargins{3cm}        % margen izquierdo
{2cm}                   % margen superior
{15cm}                  % anchura del texto
{22.5cm}                % altura del texto
{10pt}                  % altura de los encabezados
{1cm}                   % espacio entre el texto y los encabezados
{0pt}                   % altura del pie de página
{2cm}                   % espacio entre el texto y el pie de página

\begin{document}

\author {Alonso Rodríguez}
\title {Trabajo Tutelado II}

% Título
\maketitle

% Justificamos el texto
\justifying{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                     INTRODUCCIÓN                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introducción}
El objetivo de esta práctica es programar un sistema que responda a los siguientes requerimientos:
\begin{itemize}    
    \item Se dan dos conjuntos de 10 ángulos, que se almacenan en dos arrays en grados, minutos y segundos.
    \item La tarea 1 determina cuales son complementarios y cuales suplementarios.
    \item La tarea 2 cuenta el número de ángulos complementarios, enciende el LED1 (verde - PTD5) y se muestra el resultado en el LCD, hasta que el usuario pulse SW1.
    \item La tarea 3 cuenta el número de ángulos suplementarios, muestra el resultado en el LCD y enciende el LED2 (Rojo - PTE29) hasta que el usuario pulse SW1.
    \item La tarea 4 cuenta el número de ángulos que no son ni complementarios ni suplementarios, muestra el resultado en el LCD y enciende alternativamente el LED1 y el LED2
          hasta que el usuario pulse SW1.
    \item Cuando las tareas han finalizados, la tarea 5 enciende ambos leds, hasta que se pulse SW1 o SW2.
\end{itemize}

El sistema se implementa sobre la placa FRDM-KL46Z.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                    ESPECIFICACIÓN                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Especificación}
\subsection{Interfaz con el Sistema}\label{design_button_translation}
La interacción con el sistema se realiza mediante los switches físicos SW1 y SW2, y el sistema interacciona con el usuario mediante los LED Rojo, Verde, y el LCD.

\subsection{Flujo del Programa en Pseudocódigo}\label{pseudo_program_flow}
El programa debe inicializar las tareas al inicio de su ejecución (\ref{tasks}).

El funcionamiento de cada tarea será el siguiente:
\begin{itemize}
    \item init:
    \begin{samepage}    
    \begin{minted}{c}
// inicializar recursos
task5 = task_create()
// [...]
task1 = task_create()
task_delete_self()
    \end{minted}
    \end{samepage}
    \item task1:   
    \begin{minted}{c}
// Procesamos los elementos de los arrays
for(array...){
    result = compare_angles(array1, array2)

    if(result == complementary)
        // ángulos son complementarios
        // seteamos los parámetros apropiados
    else if(result == supplementary)
        // ángulos son suplementarios...
    else
        // ángulos no tienen ninguna relación...
    
    if(tarea_correspondiente_al_angulo_esta_ocupada)
        // si la tarea que maneja el tipo de ángulo detectado
        // está ocupada o pendiente de i/o con el usuario, tenemos
        // que esperar a que mande "ACK" conforme ya está lista
        os_event_wait_and(flag_del_angulo_correpondiente, NO_TIMEOUT)
    else
        // por esta rama solo se entra si la tarea no está esperando
        // input, es decir, la primera vez que encontramos un ángulo
        tarea_correspondiente_al_angulo_esta_ocupada = 1

    os_evt_set(flag_del_angulo_correspondiente, task_x);
}
// Al terminar el procesado, esperamos a que terminen todas las
// tareas para dar paso a la tarea 5, y matar el resto de tareas.
os_event_wait_and(tareas_que_quedan_por_terminar, NO_TIMEOUT)
os_task_delete(task2..4)
os_event_set(FLAG_TURNO_TASK5, task5)
task_delete_self()
    \end{minted}
    \item task2:
    \begin{samepage}    
    \begin{minted}{c}
while(1){
    // Esperamos a recibir un evento que nos indique que hay un
    // ángulo que debemos manejar
    result = os_event_wait_and(FLAG_ANGLE, NO_TIMEOUT)
    
    // Esperamos a poder tener acceso al LCD
    os_mutex_wait(lcd_mutex, NO_TIMEOUT)

    count++
    slcdDisplay(count)

    led_write(LED_GREEN, 1)
    while(!sw1){} //esperamos por input del usuario

    // Apagamos lo que encendiésemos
    led_write(LED_GREEN, 0)

    // Avisamos de que hemos terminado nuestra parte
    os_event_set(ACK_ANGLE_COMPLEMENTARY, task1)

    // Y liberamos el mutex cuando el usuario presiona el botón
    os_mutex_release(lcd_mutex)  
}
    \end{minted}
    \end{samepage}
    \item task3:
    \begin{samepage}    
    \begin{minted}{c}
while(1){
    // idem a task2 pero con LED_RED
}
    \end{minted}
    \end{samepage}
    \item task4:
    \begin{samepage}    
    \begin{minted}{c}
while(1){
    // idem a task2 pero con ambos led (alternativamente)
}
    \end{minted}
    \end{samepage}
    \item task5:
    \begin{samepage}    
    \begin{minted}{c}
// esperamos hasta que todas las tareas hayan terminado, momento
// en el cual nos llegará este evento
os_event_wait_and(FLAG_TURNO_TASK5, NO_TIMEOUT)

// mostramos nuestra salida
slcdClear();
led_write(LED_GREEN, 1)
led_write(LED_RED, 1)

while(!sw1 && !sw2){} //esperamos input

led_write(LED_GREEN, 0)
led_write(LED_RED, 0)

task_delete_self() // y terminamos
    \end{minted}
    \end{samepage}

\end{itemize}

\subsection{Diagrama de Tareas}\label{tasks}
\subsubsection{Tareas y eventos}
El diagrama muestra la comunicación que existe entre Task1 y el resto de las tasks, siguiendo el pseudocódigo propuesto en \ref{pseudo_program_flow}, en el que Task1 envía un evento
a la task correspondiente para que anote uno más y espere su turno para i/o con el usuario.

Además, se puede observar que hay dos tipos de líneas:
\begin{itemize}
    \item Las líneas sólidas indican una task activando eventos de otra.
    \item Las líneas rayadas indican los ``ACK'' que envían cada una de las tareas para indicar que están preparadas para recibir más datos.
    \item La línea rayada de init a Task1 no sabía muy bien como representarla, pero básicamente está ahí para que init pueda hacer acto de presencia, e indicar que debido a que
          el resto de tareas esperan, a efectos prácticos, al morir init, la única task que no espera eventos es Task1, por lo que le ``cede el control''.
\end{itemize}

Por legibilidad no se ha incluido la creación de las tareas, ya que todas son creadas por init al inicio del programa.

\subsubsection{Representación}

\bigskip

\begin{center}
\begin{tikzpicture}[->,>=stealth, shorten >=1pt, auto, node distance=3.2cm, semithick]
    \tikzstyle{every state}=[draw=black,text=black]

    % Nodo inicial
    \node[initial,state] (init)                                 {$\text{init}$};

    % Tareas
    \node[state, right=0.5cm]           (task1)   [below right of=init]        {$\text{Task1}$};
    \node[state, right=0.8cm]           (task2)   [above right of=task1]       {$\frac{\text{Task2}}{\text{\textcolor{green}{\punto}}}$};
    \node[state, right=0.8cm]           (task3)   [right       of=task1]       {$\frac{\text{Task3}}{\text{\textcolor{red}{\punto}}}$};
    \node[state, right=0.8cm]           (task4)   [below right of=task1]       {$\frac{\text{Task4}}{\text{\textcolor{green}{\punto} $\leftrightarrow$ \textcolor{red}{\punto}}}$};
    \node[state, right=2cm]             (task5)   [right       of=task4]       {$\frac{\text{Task5}}{\text{\textcolor{green}{\punto} \& \textcolor{red}{\punto}}}$};

    \begin{pgfinterruptboundingbox}
    \path[sloped,anchor=south]
        (task1)  edge [bend left=6,looseness=0.3]      node {COMPL}     (task2)
                 edge [bend left=6,looseness=0.3]      node {SUPL}      (task3)
                 edge [bend left=6,looseness=0.3]      node {OTRO}      (task4)
    ;
    \path[sloped,anchor=north]
        (task1)  edge [bend right=75,looseness=0.75]   node {FINAL}          (task5)
    ;
    \path[dashed]
        (task2)  edge [bend left=6,looseness=0.3]      node {}          (task1)
        (task3)  edge [bend left=6,looseness=0.3]      node {}          (task1)
        (task4)  edge [bend left=6,looseness=0.3]      node {}          (task1)
        (init)  edge []                                node {}          (task1)
    ;
    \end{pgfinterruptboundingbox}
\end{tikzpicture}
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                    IMPLEMENTACIÓN                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Implementación}
\subsection{Decisiones de diseño}
\subsubsection{Diseño de la concurrencia}\label{concurrencia_angulos}
El enunciado de la práctica da lugar a múltiples interpretaciones, por lo que he tenido que replantear la práctica un par de veces. Tal cual
lo entiendo ahora mismo, se entiende que el flujo del programa es el siguiente:
\begin{enumerate}
    \item Se inicia la placa y la tarea 1 calcula el primer ángulo, por lo que se mostrará un 1 en el LCD y se encenderá(n) el LED correspondiente.
    \item Al presionar SW1 se pasa a la siguiente tarea, es decir, si el siguiente ángulo era del mismo tipo se mostrará un 2 en el LCD, manteniendo el LED estático.
          Por otro lado si el siguiente ángulo fuese diferente, se mostrará un 1 y cambiará el patrón de los LEDs.
    \item Al terminar de presionar SW1 tantas veces como ángulos queremos comparar, se apaga el LCD y se encienden los dos LEDs: Hemos entrado en la tarea 5.
    \item Al pulsar SW1 o SW2 se apaga todo y no se hace nada más. 
\end{enumerate}

Es decir, que tomamos una aproximación ciertamente limitada por el número de inputs que puede realizar el usuario. Si el usuario no pulsa SW1, no seguimos contando.

Esto último me ha dado ciertos dolores de cabeza, ya que inicialmente la tarea 1 debía contar en segundo plano, y con SW1 se iba cambiando secuencialmente entre las tareas 2, 3 y 4,
viendo el estado del contador interno de cada una de ellas ``en directo''. Tras comentar con compañeros qué entendían en el enunciado, y tras la revisión, parece que hay un consenso
en que se debe hacer de la manera que he implementado, y \emph{espero} que esté bien.

\bigskip

Se ha optado por comunicación a través de eventos, ya que si bien los mensajes se han tenido en consideración, creo que los eventos facilitan la concurrencia en este escenario, y es que
tras comentar en la revisión que ``se debía aprovechar concurrencia'' estuve dandole vueltas a que, realmente, si únicamente hacemos comunicación a través de eventos, y no computamos
el siguiente ángulo hasta que no pulsamos el switch, no deja de ser un programa puramente secuencial, que hemos partido en tasks por hacernos la vida más difícil.

\bigskip

Debido a esto se ha implementado un sistema que aprovecha la concurrencia de una forma interesante: El siguiente ángulo siempre se computa \emph{ahead of time} (\ref{concurrencia_angulos}),
siendo el \emph{speedup} de este cambio mínimo en este caso, pero haciéndose mucho más notable si el cálculo a realizar tuviese un tiempo de procesado más elevando.

De esta forma, podemos computar hasta tres ángulos \emph{ahead of time}, \emph{e.g.}
\begin{enumerate}
    \item Ángulos complementarios -> Se activa evento en task2 -> Bloquea el mutex
    \item Ángulos suplementarios -> Se activa evento en task3 -> Espera por el mutex
    \item Ángulos sin relación -> Se activa evento en task4 -> Espera por el mutex
    \item Ángulos complementarios -> Espera a que task2 mande el ack
    \item Usuario pulsa SW1 -> task2 libera el mutex y manda ack a task1 -> task3 bloquea el mutex -> task2 recibe el ángulo complementario anteriormente en espera y bloquea el mutex de nuevo
    \item \ldots
\end{enumerate}

\bigskip

O en forma de tabla:

\begin{center}
\begin{tabular}{ | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{0.8cm} |}
    \hline
    Task1                   &   Task2        & Task3 & Task4 & i/o\\
    \hline
    Complementarios         &   Recibe evento, bloquea mutex & - & - & \textcolor{green}{\text{\punto}} \\
    \hline
    Suplementarios          &   - & Recibe evento, espera mutex & - & \textcolor{green}{\text{\punto}} \\
    \hline
    Sin Relación            &  - & - & Recibe evento, espera mutex & \textcolor{green}{\text{\punto}} \\
    \hline
    Complementarios, espera a que task2 mande ack para enviar evento         &  - & - & - & \textcolor{green}{\punto} SW1\\
    \hline
    Recibe ack de task2, y envia evento a task2   &   Libera mutex y ack a task1, espera mutex & Bloquea mutex & - & \textcolor{red}{\text{\punto}}\\
    \hline
\end{tabular}
\end{center}

\bigskip

En el peor de los casos, siempre tendremos un ángulo en espera, \emph{e.g.} solamente medimos ángulos complementarios:
\begin{enumerate}
    \item Ángulos complementarios -> Se activa evento en task2 -> Bloquea el mutex
    \item Ángulos complementarios -> Espera a que task2 mande el ack
    \item Usuario pulsa SW1 -> task2 libera el mutex y manda ack a task1 -> task2 recibe el ángulo complementario anteriormente en espera y bloquea el mutex de nuevo
    \item Ángulos complementarios -> Espera a que task2 mande el ack
    \item \ldots
\end{enumerate}

\begin{center}
\begin{tabular}{ | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{3cm} | >{\centering\arraybackslash}m{0.8cm} |}
    \hline
    Task1                   &   Task2        & Task3 & Task4 & i/o\\
    \hline
    Complementarios         &   Recibe evento, bloquea mutex & - & - & \textcolor{green}{\text{\punto}} \\
    \hline
    Complementarios, espera a que task2 mande ack para enviar evento         &  - & - & - & \textcolor{green}{\punto} SW1\\
    \hline
    Recibe ack de task2, y envia evento a task2   &   Libera mutex y ack a task1, bloquea mutex & - & - & \textcolor{green}{\text{\punto}}\\
    \hline
\end{tabular}
\end{center}

\subsubsection{Método de lectura}
Al igual que en el anterior trabajo tutelado, se ha optado por entrada salida por interrupciones, ya que requiere menos CPU, y en general, es lo suficientemente sencilla como
para permitirnos reutilizarla para esta práctica.

\subsubsection{Corner cases}\label{corner_cases}
No se han identificado corner cases, ya que cada tarea deja a lo largo de su ciclo todos los dispositivos de i/o ``como los encontró''.

Todas las tareas parten de que los LEDs están apagados, y los switches SW1 y SW2 despulsados. Para esto todas las tareas al terminar la entrada/salida con el usuario
(\ref{generic_counting_tasks}) ejecutan la función \texttt{clear\_phy()}:
\begin{samepage}
\begin{minted}{c}
    void clear_phy(void){
        setLedG(0); setLedR(0);
        sw1 = 0; sw2 = 0;
    }
\end{minted}
\end{samepage}

\subsubsection{Inicialización de los Dispositivos de i/o}
Los dispositivos de entrada (switches) y salida (LEDs), así como las rutinas de interrupción no se pueden inicializar cuando el sistema RTX está iniciado, por lo que se han de
inicializar en la función \texttt{main} antes de iniciar el sistema operativo:
\begin{minted}{c}
    int main (void) {
        // Inicializar rutinas de interrupción
        initSwitch1(sw1_pressed);
        initSwitch3(sw2_pressed);
        
        // Inicializar sLcd
        slcdInitialize();
        

        // Inicializar los LEDs poniendolos a apagado
        setLedG(0);
        setLedR(0);
        
        os_sys_init(init);
    }
\end{minted}



\subsection{Detalles de Implementación}
Creo que este trabajo no necesita de tanta explicación como el anterior, donde había que explicar cómo se interpretaban los estados, etc.

La aproximación ha sido la siguiente, la tarea 1 tenemos que programarla \emph{ad-hoc} si o si, ya que hace una función única. Sin embargo, las tareas 2 a 4 realizan la misma función
exceptuando que interaccionan con unos eventos diferentes, y encienden los LEDs con patrones diferentes, por lo que se han creado las ``tareas genéricas de conteo'', denotadas por
\texttt{task\_generic}, que como se comenta en \ref{generic_counting_tasks}, a parte de simplificar el código y seguir el principio DRY, reduce el tamaño total del programa, haciendolo
más cómodo de leer y mantenible, debido a que no hay que propagar los cambios a tres versiones casi idénticas de las tareas que cuentan ángulos.

La tarea 5 también se ha diseñado e implementado \emph{ad-hoc}.

\subsubsection{Tarea 1}
Esta tarea recorre los dos arrays de ángulos, de tamaño fijo, denotado por \texttt{ANGLE\_ARRAY\_LEN}:
\begin{minted}{c}
    #define ANGLE_ARRAY_LEN 10
\end{minted}

Al recorrerlo tenemos tres posibles resultados: 
\begin{itemize}
    \item \texttt{ANGLE\_COMPL}: Ángulo Complementario
    \item \texttt{ANGLE\_SUPPL}: Ángulo Suplementario
    \item \texttt{ANGLE\_NANGL}: Ángulos sin Relación (\texttt{\textcolor{red}{NANGL} = \textcolor{red}{N}onrelated \textcolor{red}{ANGL}es})
\end{itemize}

\bigskip

Sabiendo la relación entre los ángulos, podemos clasificarlos con el siguiente switch, el cual asigna el evento y tid que se han de emplear para comunicarse con la tarea correspondiente:
\begin{minted}{c}
    switch(result){
        case ANGLE_COMPL:
            curr_flag = FLAG_ANGLE_COMPL;
            curr_tid = t_2;
            break;
        case ANGLE_SUPPL:
            curr_flag = FLAG_ANGLE_SUPPL;
            curr_tid = t_3;
            break;
        case ANGLE_NANGL:
            curr_flag = FLAG_ANGLE_NANGL;
            curr_tid = t_4;
            break;
    }
\end{minted}

Y este bloque de código se encarga de enviar los eventos, y realizar la espera cuando una tarea ya está ocupada:
\begin{minted}{c}
    if(tasks_waiting & curr_flag){
        os_evt_wait_and(curr_flag, 0xFFFF);
    }else{
        tasks_waiting |= curr_flag;
    }

    os_evt_set(curr_flag, curr_tid);
\end{minted} 

\bigskip

Finalmente cuando todas las tareas han terminado, se matan directamente desde la tarea 1. Esta es una decisión que debido al tamaño del programa creo que es completamente lógica: No hay
tareas colgando de las tareas que cuentan, y crear un evento similar al \texttt{SIGTERM} de Linux sería complicar el código innecesariamente cuando tenemos una función que hace muy bien 
lo que promete y es mucho más sencilla.
\begin{minted}{c}
    os_evt_wait_and(tasks_waiting, 0xFFFF);
    os_tsk_delete(t_2);
    os_tsk_delete(t_3);
    os_tsk_delete(t_4);
    os_evt_set(1, t_5);
    
    os_tsk_delete_self(); // Cuando hayamos terminado, salimos
\end{minted}

Línea importante aquí es \texttt{os\_evt\_wait\_and(tasks\_waiting, 0xFFFF);}, que hace que si por ejemplo nuestro programa solamente ha contado ángulos complementarios no espere por
las tareas de los suplementarios y los sin clasificar, ya que nunca enviarán nada, y quedará bloqueado.

\subsubsection{Tareas Genéricas de Conteo}\label{generic_counting_tasks}
Tras una idea feliz antes de ir a dormir el día anterior a cuando pensaba entregar, se me ocurrió la \emph{ahora obvia} idea de que podía juntar las tareas de conteo en una sola tarea
genérica, no para ganar en velocidad, pero sí para ganar en mantenibilidad y ser más rigurosos con el principio DRY, a parte de reducir el tamaño del código, puesto que tenemos menos código
de repetido para las funciones de conteo, a cambio de una ligeramente mayor y genérica.

\bigskip

Así, y siguendo el pseudocódigo en \ref{pseudo_program_flow}, la implementación de la tarea genérica es:
\begin{minted}{c}
    __task void task_generic(void* argv){
        uint16_t count = 0;
        
        #define my_flag (*(uint16_t*) argv)
        //uint16_t my_flag = *(uint16_t*) argv;
        
        while(1){
            if(os_evt_wait_or(my_flag, 0xFFFF) == OS_R_EVT){
                
                os_mut_wait(mut_1, 0xFFFF);
                
                count++;
                slcdDisplay(count, 10);
                
                switch(my_flag){
                    case FLAG_ANGLE_COMPL:
                        setLedG(1);
                        while(!sw1){os_dly_wait(DEFAULT_WAIT_TIME);}
                        break;
                    case FLAG_ANGLE_SUPPL:
                        setLedR(1);
                        while(!sw1){os_dly_wait(DEFAULT_WAIT_TIME);}
                        break;
                    case FLAG_ANGLE_NANGL:
                        while(!sw1){
                            setLedG(0);
                            setLedR(1);
                            os_dly_wait(DEFAULT_WAIT_TIME);
                            setLedG(1);
                            setLedR(0);
                            os_dly_wait(DEFAULT_WAIT_TIME);
                        }
                        break;
                }

                clear_phy();
                os_evt_set(my_flag, t_1);
                
                os_mut_release(mut_1);
            }
        }
        #undef my_flag
    }
\end{minted}

En esta tarea podemos observar varias cosas, la primera y más evidente es la línea:
\begin{minted}{c}
    #define my_flag (*(uint16_t*) argv)
    //uint16_t my_flag = *(uint16_t*) argv;
\end{minted}
que sustituye a la asignación de la variable que había anteriormente en su lugar, y que por claridad se ha dejado debajo como comentario. De esta forma se evita una instrucción de
asignación, el uso de memoria en el stack, y no hay inconvenientes, puesto que el tiempo de acceso es el mismo. Lo que si, es necesario hacer \texttt{\#undef my\_flag} al final de la
función para imitar el funcionamiento de cuando la variable cae \emph{out of scope}, es decir, poder utilizar otras variables llamadas \texttt{my\_flag} a lo largo del código. 

Con esta asignación accedemos al parámetro que pasamos desde la creación de la tarea, en init (\ref{task_init}).

\bigskip

Continuando tenemos el switch de \texttt{my\_flag}, que define el comportamiento particular de la función, según escuche un tipo u otro de ángulos:
\begin{minted}{c}
    switch(my_flag){
        case FLAG_ANGLE_COMPL:
            setLedG(1);
            while(!sw1){os_dly_wait(DEFAULT_WAIT_TIME);}
            break;
        case FLAG_ANGLE_SUPPL:
            setLedR(1);
            while(!sw1){os_dly_wait(DEFAULT_WAIT_TIME);}
            break;
        case FLAG_ANGLE_NANGL:
            while(!sw1){
                setLedG(0);
                setLedR(1);
                os_dly_wait(DEFAULT_WAIT_TIME);
                setLedG(1);
                setLedR(0);
                os_dly_wait(DEFAULT_WAIT_TIME);
            }
            break;
    }
\end{minted}

Al terminar, como se menciona en \ref{corner_cases}, se ejecuta \texttt{clear\_phy()}, para dejar la i/o como se encontró.

\subsubsection{Tarea init}\label{task_init}
La tarea init no tiene mayor complicación: inicializa los recursos que gestiona el sistema operativo (los mutexes) y las tareas.
\begin{minted}{c}
    __task void init(void){
        os_mut_init(mut_1);
        t_5 = os_tsk_create(task_5, 1);
        t_4 = os_tsk_create_ex(task_generic, 1, (void*) &flags_by_task[2]);
        t_3 = os_tsk_create_ex(task_generic, 1, (void*) &flags_by_task[1]);
        t_2 = os_tsk_create_ex(task_generic, 1, (void*) &flags_by_task[0]);
        t_1 = os_tsk_create(task_1, 1);
        os_tsk_delete_self();
    }
\end{minted}

Como se puede observar, se inicializa el mutex, se crean las tareas en orden inverso (no por ninguna razón en particular, funcionaría exactamente igual si se invirtiese), 
y finalmente se elimina a si misma.

\bigskip

El array \texttt{flags\_by\_task} es el siguiente:
\begin{minted}{c}
    const uint16_t flags_by_task[3] = {FLAG_ANGLE_COMPL, FLAG_ANGLE_SUPPL,
                                       FLAG_ANGLE_NANGL};
\end{minted}
que como se puede ver, se almacena en la zona de constantes.

Realmente se puede castear el valor del propio flag a (void*) y dentro de la tarea no recorrer el puntero, pero un poco por seguir la convención, he decidido pasar el valor apuntado, 
que, de todos modos, no crea prácticamente overhead, ya que la complejidad del acceso a memoria fuera de un for es constante O(1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                  DESCRIPCIÓN EVENTOS                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Intercomunicación mediante Eventos}
\subsection{Motivación}
Los sistemas informáticos necesitan comunicación entre ellos, y para satisfacer esta necesidad existen múltiples paradigmas.
En nuestro caso necesitamos comunicación entre procesos, y como se explica en el temario de la asignatura, existen múltiples
opciones para realizar esto mismo, entre otras:
\begin{itemize}
    \item Comunicación mediante Eventos
    \item Comunicación mediante Mensajes (Uso de una Mailbox)
\end{itemize}

\subsection{Decisión de Diseño}
En este caso se ha escogido la comunicación por eventos. Inicialmente pensé en una comunicación mediante mensajes, pero me decanté por eventos debido a que consideraba que podía
aprender más utilizando los eventos. De todos modos, después de la primera reunión me quedó claro que el planteamiento que estaba siguiendo no era el adecuado (calcular los ángulos
inicialmente), y viendo la implementación actual, definitivamente una comunicación por eventos es una aproximación mucho más adecuada que por mensajes, quedando un sistema dinámico,
en el que usamos los elementos casi como ``paquetes enrutados'', que llegan a ``puertos'' en las tareas, haciendo un símil con una red IP.

Todo esto desde mi punto de vista hace que resulte un sistema conceptualmente bastante satisfactorio, en el que podemos visualizar una dinámica comunicación inter-proceso aprovechando
la concurrencia en mayor o menor medida según el dataset, pero definitivamente, más rápido que realizando un enfoque puramente secuencial.

\subsection{Explicación detallada}
No he encontrado tanta información como me gustaría acerca de este tema, a parte de la documentación de \emph{ARM
Keil} \autocite[\text{Event Flag Management}]{keil_function_reference}.

En esta se comenta que para la programación basada en eventos contamos con 6 rutinas, con las que podemos realizar toda la gestión de eventos:
\begin{samepage}
\begin{center}
\begin{tabular}{ | c | >{\centering\arraybackslash}m{11cm} | }
    \hline
    Rutina              &   Descipción\\
    \hline
    \texttt{os\_evt\_clr}        &   Elimina uno o más event flags de una tarea\\
    \hline
    \texttt{os\_evt\_get}        &   Devuelve las eventa flags que hicieron salir del \texttt{os\_evt\_wait\_or}\\
    \hline
    \texttt{os\_evt\_set}        &   Activa una o más flags de un evento de una tarea\\
    \hline
    \texttt{os\_evt\_wait\_and}  &   Espera a que se activen todos los flags necesarios\\
    \hline
    \texttt{os\_evt\_wait\_or}   &   Espera a que se active alguno de los flags necesarios\\
    \hline
    \texttt{isr\_evt\_set}       &   Activa una o más flags de un evento de una tarea, sólo activable desde dentro de una rutina de interrupción\\
    \hline
\end{tabular}
\end{center}
\end{samepage}

Pero en general, se entra en muy poco detalle acerca de cómo funciona la comunicación interproceso. Por suerte, durante el desarrollo de la práctica me surgieron dudas, las cuales
voy a explicar detalladamente. Además, debido a una de estas dudas encontré en el foro de Keil que el código fuente de RTX es abierto y se encuentra en la carpeta de instalación de Keil,
lo cual ayudó a disipar muchas dudas acerca del comportamiento de funciones como \texttt{os\_evt\_wait\_or/and} sin tener que recurrir a la profesora.

\subsubsection{Problema al Compilar el Proyecto}
Nada más comenzar el primer fallo: El proyecto no compila. Parece que a varios compañeros les pasa lo mismo y nadie sabe cómo arreglarlo. Afortunadamente en este foro
\parencite{solucionar_rtx_undefined_symbol} aclaran cuál era el problema, y nada más incluir el archivo \texttt{RTX\_config.c} ya todo funcionó correctamente.

\subsubsection{Programación basada en eventos}
Tras esto me quedaron muchas dudas acerca de la implementación de las funciones de wait y set:

Las funciones \texttt{os\_evt\_wait\_or/and} eliminan todas las flags que esperan? Solo las que activaron el evento en el caso de la or\ldots? La verdad es que no tenía nada
claro el comportamiento, y como estaba teniendo problemas con el código, no tenía claro si mis suposiciones eran ciertas o no (que al final terminaron siendo).

La respuesta es clara: Tanto \texttt{os\_evt\_wait\_or} como \texttt{os\_evt\_wait\_and} eliminan las flags que están esperando. Esto se puede consultar en la implementación como comenta
el usuario Måns Andersson en \citetitle{arm_forum_asking_for_source_code_rtx} en la ruta
\texttt{<keil-dir>$\backslash$ARM$\backslash$RL$\backslash$RTX$\backslash$SRC},
siendo el archivo que nos interesa en nuestro caso \texttt{$\backslash$Keil$\backslash$ARM$\backslash$RL$\backslash$RTX$\backslash$SRC$\backslash$ARM$\backslash$rt\_Event.c}, donde podemos
ver claramente en la función
\begin{minted}{c}
    OS_RESULT os_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait)    
\end{minted}
lo mencionado en los comentarios:
\begin{minted}{c}
    if (and_wait) {
        /* Check for AND-connected events */

        /* Aquí podemos ver claramente que es una AND, a parte de por
         * el comentario de arriba, porque el and lógico se compara
         * con las wait_flags, devolviendo solamente 1 si coinciden
         * todas y cada una de ellas
         */
        if ((os_runtask->events & wait_flags) == wait_flags) {
        os_runtask->events &= ~wait_flags; // **1**
        tsk_unlock();
        return (OS_R_EVT);
        }
        block_state = WAIT_AND;
    }
    else {
        /* Check for OR-connected events */
        /* Y aquí podemos ver que es una OR, porque unicamente
         * checkeamos que alguna de ellas sea 1
         */
        if (os_runtask->events & wait_flags) {
        os_runtask->waits = os_runtask->events & wait_flags;
        os_runtask->events &= ~wait_flags; // **2**
        tsk_unlock();
        return (OS_R_EVT);
        }
        block_state = WAIT_OR;
    }
\end{minted}

en especial las líneas con los comentarios \texttt{// **1**  } y \texttt{// **2**  }, que indican claramente
que cuando el wait se activa, sólamente las flags por las que estamos esperando se ponen a cero (\texttt{os\_runtask->events \&= $\thicksim$wait\_flags;}).
Esto quiere decir que (menos mal) no tenemos que hacer \texttt{os\_evt\_clr} al terminar un wait.

\subsubsection{Más detalle de los eventos}
Realmente, mirando los manuales de programación no hay mucha información acerca de los mismos, a parte de cómo se usan, y no tanto cómo funcionan, pero en \autocite[28]{rl_arm_gs}
se entra en un poco más de detalle:
\begin{itemize}
    \item Cuando la tarea se crea, se le asigna un TSB (Task Control Block), que sería un equivalente al PCB (Process Control Block) en sistemas *NIX
          \parencite{process_control_block_pcb_wikipedia}, donde hay 16 bits para sus event flags, que independientemente de si el código está esperando o no se pueden setear a uno.
          Por esta razón, en \ref{task_init} se comenta que no hay especial problema en inicializar las tareas al derecho o al revés, y que por lo tanto en \ref{generic_counting_tasks}
          no tenemos que mandar un evento a la tarea 1 conforme ya están inicializadas ni nada similar.
          Ya que si bien la tarea puede no haber llegado a un wait cuando se le activa un evento, al estar éste activado en la TCB, que se
          crea a la vez que la tarea, simplemente leerá de las flags y verá que los bits en las event flags ya coinciden con su requerimiento, continuando directamente.
\end{itemize}
Lo cual se puede observar en las primeras líneas de la implementación de \texttt{os\_evt\_set}:
\begin{minted}{c}
    void os_evt_set (U16 event_flags, OS_TID task_id) {
    /* Set one or more event flags of a selectable task. */
    P_TCB p_tcb;

    p_tcb = os_active_TCB[task_id-1];
    if (p_tcb == NULL) {
        return;
    }
    tsk_lock();
    p_tcb->events |= event_flags;
    event_flags    = p_tcb->waits;
    /* If the task is not waiting for an event, it should not be put */
    /* to ready state. */
    if (p_tcb->state == WAIT_AND) {
        /* Check for AND-connected events */
        if ((p_tcb->events & event_flags) == event_flags) {
        goto wkup;
        }
    }
    if (p_tcb->state == WAIT_OR) {
        /* Check for OR-connected events */
        if (p_tcb->events & event_flags) {
        p_tcb->waits  &= p_tcb->events;
    wkup: p_tcb->events &= ~event_flags;
        os_rmv_dly (p_tcb);
        p_tcb->state   = READY;
        p_tcb->ret_val = OS_R_EVT;
        os_dispatch (p_tcb);
        }
    }
    tsk_unlock();
    }
\end{minted}

El resto se cubre muy por encima y no es nada que no se haya explicado previamente en clase.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                    OPINIÓN PERSONAL                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Opinión Personal}
\subsection{Desafíos}
No voy a negar que debido a no entendía muy bien el enunciado, tuve que rehacer el planteamiento de la práctica, por lo que como sugerencia para años siguiente, propondría escribir
el enunciado de forma menos abierta a interpretación, adjuntar un pequeño esquema, o en clase el día de la presentación del enunciado.

Durante la realización me bloqueé en dos fallos, el primero muy tonto (esperar por una tarea que estaba muerta por olvidarme de borrar una línea), y otro más complicado, que era el cómo
maximizar la concurrencia hasta el punto de esta entrega, en el que podemos calcular hasta tres ángulos por adelantado, que resolví satisfactoriamente dando el resultado expuesto
en \ref{concurrencia_angulos}.

\subsection{Aprendizajes}
A lo largo de la realización de esta práctica he aprendido un paradigma de programación multitarea basado en eventos, que al principio no parece complicado, pero es sorprendente que
a un concepto tan simple podamos darle usos tan versátiles. Por lo que \emph{espero} haber asimilado los conceptos adecuadamente en esta última práctica de la asignatura, que la verdad
siempre es un gusto programar en C, ya que es un lenguaje que no requiere buscar en internet tutoriales de veinte librerías y otorga mucho control, cosa que en la programación de sistemas
empotrados es muy importante.


\clearpage
\begin{flushleft}
\printbibliography[]{}
\end{flushleft}
\end{document}